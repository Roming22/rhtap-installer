
# Source: dance/templates/configure.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: "dance-installer-configure"
  labels:
    app.kubernetes.io/managed-by: "Helm"
    app.kubernetes.io/instance: "installer"
    app.kubernetes.io/version: 2.1.0
    helm.sh/chart: "dance-0.5.11"
  annotations:
    # This is what defines this resource as a hook. Without this line, the
    # job is considered part of the release.
    "helm.sh/hook": post-install, post-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  template:
    metadata:
      name: "installer-configure"
      labels:
        app.kubernetes.io/managed-by: "Helm"
        app.kubernetes.io/instance: "installer"
        helm.sh/chart: "dance-0.5.11"
    spec:
      containers:
                
        - name: configure-acs
          image: "quay.io/codeready-toolchain/oc-client-base:latest"
          command:
            - /bin/bash
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
        
              CRDS=( pipelines tasks )
              for CRD in "${CRDS[@]}"; do
                echo -n "* Waiting for '$CRD' CRD: "
                while [ $(kubectl api-resources | grep -c "^$CRD ") = "0" ] ; do
                  echo -n "."
                  sleep 3
                done
                echo "OK"
              done
        
              echo -n "* Configuring Tasks: "
              cat << EOF | kubectl apply -f - >/dev/null
                      
                apiVersion: tekton.dev/v1
                kind: Task
                metadata:
                  name: acs-deploy-check
                spec:
                  description: >-
                    Policy check a deployment with StackRox/RHACS This tasks allows you to check
                    a deployment against build-time policies and apply enforcement to fail
                    builds. It's a companion to the stackrox-image-scan task, which returns full
                    vulnerability scan results for an image.
                  params:
                    - default:  "central.acs.mycluster.com:443"
                      description: |
                        Secret containing the address:port tuple for StackRox Central
                        (example - rox.stackrox.io:443)
                      name: rox_central_endpoint
                      type: string
                    - default: "eyAbC123...acs...890XyZ"
                      description: |
                        Secret containing the StackRox API token with CI permissions
                      name: rox_api_token
                      type: string
                    - description: |
                        URL to the deployment
                        (example - https://raw.gitlab.mycompany.com/myorg/myapp/mybranch/argocd/mycomponent/myenv/deployment.yaml)
                      name: deployment_url
                      type: string
                    - default: 'false'
                      description: |
                        When set to \`"true"\`, skip verifying the TLS certs of the Central
                        endpoint.  Defaults to \`"false"\`.
                      name: insecure-skip-tls-verify
                      type: string
                  results:
                    - description: Output of \`roxctl deployment check\`
                      name: check_output
                  steps:
                    - env:
                      - name: ROX_API_TOKEN
                        value: \$(params.rox_api_token)
                      - name: ROX_ENDPOINT
                        value: \$(params.rox_central_endpoint)
                      image: registry.access.redhat.com/ubi8/ubi-minimal
                      name: rox-deploy-scan
                      script: |
                        #!/usr/bin/env bash
                        set -o errexit
                        set -o nounset
                        set -o pipefail
                
                        curl -s -k -L -H "Authorization: Bearer \$ROX_API_TOKEN" \
                          "https://\$ROX_ENDPOINT/api/cli/download/roxctl-linux" \
                          --output ./roxctl  \
                          > /dev/null
                        chmod +x ./roxctl  > /dev/null
                
                        curl --fail --insecure --location --output deployment.yaml --silent "\$(params.deployment_url)"
                
                        ./roxctl deployment check \
                          \$(
                            [ "\$(params.insecure-skip-tls-verify)" = "true" ] && \
                            echo -n "--insecure-skip-tls-verify"
                          ) \
                          --file "deployment.yaml" \
                          --output json > check.log
                          cat check.log
                      workingDir: /tmp
                
              EOF
              echo -n "."
              cat << EOF | kubectl apply -f - >/dev/null
                      
                apiVersion: tekton.dev/v1
                kind: Task
                metadata:
                  name: acs-image-check
                spec:
                  description: |
                    Policy check an image with StackRox/RHACS This tasks allows you to
                    check an image against build-time policies and apply enforcement to fail builds.
                    It's a companion to the acs-image-scan task, which returns full vulnerability
                    scan results for an image.
                  params:
                  - default: "central.acs.mycluster.com:443"
                    description: |
                      Secret containing the address:port tuple for StackRox Central
                      (example - rox.stackrox.io:443)
                    name: rox_central_endpoint
                    type: string
                  - default: "eyAbC123...acs...890XyZ"
                    description: |
                      Secret containing the StackRox API token with CI permissions
                    name: rox_api_token
                    type: string
                  - description: |
                      Full name of image to scan (example -- gcr.io/rox/sample:5.0-rc1)
                    name: image
                    type: string
                  - default: "false"
                    description: |
                      When set to \`"true"\`, skip verifying the TLS certs of the Central
                      endpoint.  Defaults to \`"false"\`.
                    name: insecure-skip-tls-verify
                    type: string
                  - description: |
                      Digest of the image
                    name: image_digest
                    type: string
                  results:
                  - description: Output of \`roxctl image check\`
                    name: check_output
                  steps:
                  - env:
                    - name: ROX_API_TOKEN
                      value: \$(params.rox_api_token)
                    - name: ROX_ENDPOINT
                      value: \$(params.rox_central_endpoint)
                    image: registry.access.redhat.com/ubi8/ubi-minimal
                    name: rox-image-check
                    workingDir: /tmp
                    script: |
                      #!/usr/bin/env bash
                      set -o errexit
                      set -o nounset
                      set -o pipefail
                      set -x
                
                      # Install roxctl
                      curl --fail --insecure --location --silent \
                        --header "Authorization: Bearer \$ROX_API_TOKEN" \
                        --output ./roxctl  \
                        "https://\$ROX_ENDPOINT/api/cli/download/roxctl-linux" \
                        > /dev/null
                      chmod +x ./roxctl  > /dev/null
                
                      # Check image
                      IMAGE=\$(params.image)@\$(params.image_digest)
                      ./roxctl image scan --force \
                        \$(
                          [ "\$(params.insecure-skip-tls-verify)" = "true" ] && \
                          echo -n "--insecure-skip-tls-verify"
                        ) \
                        --image "\$IMAGE" \
                        --output json > check.log
                
                      cat check.log
                
              EOF
              echo -n "."
              cat << EOF | kubectl apply -f - >/dev/null
                      
                apiVersion: tekton.dev/v1
                kind: Task
                metadata:
                  name: acs-image-scan
                spec:
                  description: |
                    Retrun a full vulnerability scan results for an image.
                  params:
                  - default: "central.acs.mycluster.com:443"
                    description: |
                      Secret containing the address:port tuple for StackRox Central
                      (example - rox.stackrox.io:443)
                    name: rox_central_endpoint
                    type: string
                  - default: "eyAbC123...acs...890XyZ"
                    description: |
                      Secret containing the StackRox API token with CI permissions
                    name: rox_api_token
                    type: string
                  - description: |
                      Full name of image to scan (example -- gcr.io/rox/sample:5.0-rc1)
                    name: image
                    type: string
                  - default: "false"
                    description: |
                      When set to \`"true"\`, skip verifying the TLS certs of the Central
                      endpoint.  Defaults to \`"false"\`.
                    name: insecure-skip-tls-verify
                    type: string
                  - description: |
                      Digest of the image
                    name: image_digest
                    type: string
                  results:
                  - description: Output of \`roxctl image check\`
                    name: check_output
                  steps:
                  - env:
                    - name: ROX_API_TOKEN
                      value: \$(params.rox_api_token)
                    - name: ROX_ENDPOINT
                      value: \$(params.rox_central_endpoint)
                    image: registry.access.redhat.com/ubi8/ubi-minimal
                    name: rox-image-check
                    workingDir: /tmp
                    script: |
                      #!/usr/bin/env bash
                      set -o errexit
                      set -o nounset
                      set -o pipefail
                      set -x
                
                      # Install roxctl
                      curl --fail --insecure --location --silent \
                        --header "Authorization: Bearer \$ROX_API_TOKEN" \
                        --output ./roxctl  \
                        "https://\$ROX_ENDPOINT/api/cli/download/roxctl-linux" \
                        > /dev/null
                      chmod +x ./roxctl  > /dev/null
                
                      # Scan image
                      IMAGE=\$(params.image)@\$(params.image_digest)
                      ./roxctl image scan --force \
                        \$(
                          [ "\$(params.insecure-skip-tls-verify)" = "true" ] && \
                          echo -n "--insecure-skip-tls-verify"
                        ) \
                        --image "\$IMAGE" \
                        --output json > scan.log
                
                      cat scan.log
                
              EOF
              echo -n "."
              echo "OK"
        
              echo
              echo "Configuration successful"
        
                
        - name: configure-developer-hub
          image: "quay.io/codeready-toolchain/oc-client-base:latest"
          command:
            - /bin/bash
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
        
              YQ_VERSION="v4.40.5"
              curl --fail --location --output "/usr/bin/yq" --silent --show-error "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
              chmod +x "/usr/bin/yq"
        
              CHART="dance"
        
              echo -n "* Waiting for route: "
            
              PREFIX="installer-"
            
              until kubectl get route "${PREFIX}developer-hub" -o name >/dev/null ; do
                echo -n "."
                sleep 3
              done
              HOSTNAME="$(kubectl get routes "${PREFIX}developer-hub" -o jsonpath="{.spec.host}")"
              echo -n "."
              if [ "$(kubectl get secret "$CHART-developer-hub-secret" -o name --ignore-not-found | wc -l)" = "0" ]; then
                kubectl create secret generic "$CHART-developer-hub-secret" \
                  --from-literal="hostname=$HOSTNAME" >/dev/null
              fi
              echo "OK"
        
              kubectl get configmap ${PREFIX}developer-hub-app-config -o yaml > developer-hub-app-config.current.yaml
              yq '.data.["app-config.yaml"]' developer-hub-app-config.current.yaml > app-config.yaml
        
              # Set the base URL
              URL="https://$HOSTNAME"
              yq -i ".app.baseUrl = \"$URL\" | .backend.baseUrl = \"$URL\" |.backend.cors.origin = \"$URL\"" app-config.yaml
        
              # Set the authentication
            
              cat << _EOF_ > app-config-update.yaml
              auth:
                environment: development
                providers:
                  github:
                    development:
                      clientId: abcd1234cdef7890
                      clientSecret: abcd1234...cdef7890
              catalog:
                locations:
                - target: https://github.com/my-org/my-gpt-repo/blob/my-branch/my-catalog.yaml
                  type: url
                rules:
                - allow:
                  - Component
                  - System
                  - Group
                  - Resource
                  - Location
                  - Template
                  - API
              integrations:
                github:
                - apps:
                  - appId: ${GITHUB_APP_APP_ID}
                    clientId: ${GITHUB_APP_CLIENT_ID}
                    clientSecret: ${GITHUB_APP_CLIENT_SECRET}
                    privateKey: |
                      ${GITHUB_APP_PRIVATE_KEY}
                    webhookSecret: ${GITHUB_APP_WEBHOOK_SECRET}
                    webhookUrl: ${GITHUB_APP_WEBHOOK_URL}
                  host: github.com
              _EOF_
              yq -i '. *= load("app-config-update.yaml")' app-config.yaml
            
              yq ".data.[\"app-config.yaml\"] = \"$(cat app-config.yaml | sed 's:":\\":g')\"" developer-hub-app-config.current.yaml > developer-hub-app-config.new.yaml
              if [ "$(md5sum developer-hub-app-config.current.yaml | cut -d' ' -f1)" != "$(md5sum developer-hub-app-config.new.yaml | cut -d' ' -f1)" ]; then
                md5sum developer-hub-app-config.current.yaml
                md5sum developer-hub-app-config.new.yaml
                echo
                cat developer-hub-app-config.current.yaml
                echo
                cat developer-hub-app-config.new.yaml
                kubectl apply -f developer-hub-app-config.new.yaml
                kubectl delete pods -l "app.kubernetes.io/component=backstage"
              fi
        
              echo -n "* Waiting for UI: "
              until curl --fail --insecure --location --output /dev/null --silent "$URL"; do
                echo -n "."
                sleep 3
              done
              echo "OK"
        
              echo
              echo "Configuration successful"
        
                
        - name: configure-gitops
          image: "quay.io/codeready-toolchain/oc-client-base:latest"
          command:
            - /bin/sh
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
        
              echo -n "* Installing 'argocd' CLI: "
              curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
              chmod 555 argocd
              ./argocd version --client | head -1 | cut -d' ' -f2
              
              CRD="argocds"
              echo -n "* Waiting for '$CRD' CRD: "
              while [ $(kubectl api-resources | grep -c "^$CRD ") = "0" ] ; do
                echo -n "."
                sleep 3
              done
              echo "OK"
        
              echo -n "* Waiting for gitops operator deployment: "
              until kubectl get "$CRD" openshift-gitops -n openshift-gitops >/dev/null 2>&1; do
                echo -n "."
                sleep 3
              done
              echo "OK"
        
              #
              # All actions must be idempotent
              #
              CHART="dance"
              ARGOCD_NAMESPACE="dance-argocd"
              echo -n "* ArgoCD resource: "
              until kubectl get namespace "$ARGOCD_NAMESPACE" >/dev/null 2>&1; do
                echo -n "."
                sleep 3
              done
              cat << EOF | kubectl apply -n "$ARGOCD_NAMESPACE" -f - >/dev/null
                      
                apiVersion: argoproj.io/v1beta1
                kind: ArgoCD
                metadata:
                  name: dance-argocd
                spec:
                  server:
                    autoscale:
                      enabled: false
                    grpc:
                      ingress:
                        enabled: false
                    ingress:
                      enabled: false
                    resources:
                      limits:
                        cpu: 500m
                        memory: 256Mi
                      requests:
                        cpu: 125m
                        memory: 128Mi
                    route:
                      enabled: true
                    service:
                      type: ''
                  grafana:
                    enabled: false
                    ingress:
                      enabled: false
                    resources:
                      limits:
                        cpu: 500m
                        memory: 256Mi
                      requests:
                        cpu: 250m
                        memory: 128Mi
                    route:
                      enabled: false
                  monitoring:
                    enabled: false
                  notifications:
                    enabled: false
                  prometheus:
                    enabled: false
                    ingress:
                      enabled: false
                    route:
                      enabled: false
                  initialSSHKnownHosts: {}
                  sso:
                    dex:
                      openShiftOAuth: true
                      resources:
                        limits:
                          cpu: 500m
                          memory: 256Mi
                        requests:
                          cpu: 250m
                          memory: 128Mi
                    provider: dex
                  applicationSet:
                    resources:
                      limits:
                        cpu: '2'
                        memory: 1Gi
                      requests:
                        cpu: 250m
                        memory: 512Mi
                    webhookServer:
                      ingress:
                        enabled: false
                      route:
                        enabled: false
                  rbac:
                    defaultPolicy: ''
                    policy: |
                      g, system:cluster-admins, role:admin
                      g, cluster-admins, role:admin
                    scopes: '[groups]'
                  repo:
                    resources:
                      limits:
                        cpu: '1'
                        memory: 1Gi
                      requests:
                        cpu: 250m
                        memory: 256Mi
                  resourceExclusions: |
                    - apiGroups:
                      - tekton.dev
                      clusters:
                      - '*'
                      kinds:
                      - TaskRun
                      - PipelineRun
                  ha:
                    enabled: false
                    resources:
                      limits:
                        cpu: 500m
                        memory: 256Mi
                      requests:
                        cpu: 250m
                        memory: 128Mi
                  tls:
                    ca: {}
                  redis:
                    resources:
                      limits:
                        cpu: 500m
                        memory: 256Mi
                      requests:
                        cpu: 250m
                        memory: 128Mi
                  controller:
                    processors: {}
                    resources:
                      limits:
                        cpu: '2'
                        memory: 2Gi
                      requests:
                        cpu: 250m
                        memory: 1Gi
                  extraConfig:
                    accounts.admin-dance: apiKey
                
              EOF
              echo "OK"
        
              echo -n "* ArgoCD dashboard: "
              test_cmd="kubectl get route -n "$ARGOCD_NAMESPACE" "$CHART-argocd-server" --ignore-not-found -o jsonpath={.spec.host}"
              ARGOCD_HOSTNAME="$(${test_cmd})"
              until curl --fail --insecure --output /dev/null --silent "https://$ARGOCD_HOSTNAME"; do
                echo -n "."
                sleep 2
                ARGOCD_HOSTNAME="$(${test_cmd})"
              done
              echo "OK"
        
              echo -n " * ArgoCD admin user: "
              if [ "$(kubectl get argocd -n "$ARGOCD_NAMESPACE" "$CHART-argocd" -o jsonpath='{.spec.extraConfig.admin\.enabled}')" = "false" ]; then
                echo "disabled"
                echo -n "* ArgoCD 'admin-$CHART' token: "
                if kubectl get secret -n dance-installer dance-argocd-secret >/dev/null; then
                  echo "already generated"
                else
                  echo "not available"
                  echo "[ERROR] Missing ArgoCD token cannot be created"
                  exit 1
                fi
              else
                echo "enabled"
                echo -n "* ArgoCD Login: "
                ARGOCD_PASSWORD="$(kubectl get secret -n "$ARGOCD_NAMESPACE" "$CHART-argocd-cluster" -o jsonpath="{.data.admin\.password}" | base64 --decode)"
                ./argocd login "$ARGOCD_HOSTNAME" --grpc-web --insecure --username admin --password "$ARGOCD_PASSWORD" >/dev/null
                echo "OK"
                # echo "argocd login '$ARGOCD_HOSTNAME' --grpc-web --insecure --username admin --password '$ARGOCD_PASSWORD'"
        
                echo -n "* ArgoCD 'admin-$CHART' token: "
                if [ "$(kubectl get secret "$CHART-argocd-secret" -o name --ignore-not-found | wc -l)" = "0" ]; then
                  echo -n "."
                  API_TOKEN="$(./argocd account generate-token --account "admin-$CHART")"
                  echo -n "."
                  kubectl create secret generic "$CHART-argocd-secret" \
                    --from-literal="api-token=$API_TOKEN" \
                    --from-literal="hostname=$ARGOCD_HOSTNAME" >/dev/null
                fi
                echo "OK"
        
                echo -n "* Disable ArgoCD admin user: "
                kubectl patch argocd -n "$ARGOCD_NAMESPACE" "$CHART-argocd" --type 'merge' --patch '        
                {
                  "spec": {
                    "extraConfig": {
                      "admin.enabled": "false"
                    }
                  }
                }
                ' >/dev/null
                echo "OK"
              fi
        
              echo
              echo "Configuration successful"
        
                
        - name: configure-namespace
          image: "quay.io/codeready-toolchain/oc-client-base:latest"
          command:
            - /bin/bash
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
        
              CRDS=( pipelines tasks )
              for CRD in "${CRDS[@]}"; do
                echo -n "* Waiting for '$CRD' CRD: "
                while [ $(kubectl api-resources | grep -c "^$CRD ") = "0" ] ; do
                  echo -n "."
                  sleep 3
                done
                echo "OK"
              done
        
              echo -n "* Configuring Tasks: "
              cat << EOF | kubectl apply -f - >/dev/null
                      
                apiVersion: tekton.dev/v1
                kind: Task
                metadata:
                  name: dance-dev-namespace-setup
                spec:
                  description: >-
                    Create the required resources for dance tasks to run in a namespace.
                  params:
                    - description: |
                        Secret containing the address:port tuple for StackRox Central
                        (example - rox.stackrox.io:443)
                      name: acs_central_endpoint
                      type: string
                    - description: |
                        Secret containing the StackRox API token with CI permissions
                      name: acs_api_token
                      type: string
                  steps:
                    - env:
                      - name: ROX_API_TOKEN
                        value: \$(params.acs_api_token)
                      - name: ROX_ENDPOINT
                        value: \$(params.acs_central_endpoint)
                      image: "k8s.gcr.io/hyperkube:v1.12.1"
                      name: setup
                      script: |
                        #!/usr/bin/env bash
                        set -o errexit
                        set -o nounset
                        set -o pipefail
                        
                        echo "Generating secret: "
                        kubectl create secret generic dance-secret \
                          --from-literal=rox_central_endpoint=\$ROX_ENDPOINT \
                          --from-literal=rox_api_token=\$ROX_API_TOKEN \
                          --dry-run -o yaml | kubectl apply -f - >/dev/null
                        echo "OK"
                
                        echo "Namespace is ready to execute dance pipelines"
                      workingDir: /tmp
                
              EOF
              echo -n "."
              cat << EOF | kubectl apply -f - >/dev/null
                      
                apiVersion: tekton.dev/v1
                kind: Task
                metadata:
                  name: dance-pe-info
                spec:
                  description: >-
                    Display the configuration information needed by the Platform
                    Engineer to configure the RHDH.
                  steps:
                    - env:
                      - name: ARGOCD_HOSTNAME
                        valueFrom:
                          secretKeyRef:
                            name: dance-argocd-secret
                            key: hostname
                      - name: ARGOCD_TOKEN
                        valueFrom:
                          secretKeyRef:
                            name: dance-argocd-secret
                            key: api-token
                      - name: DEVELOPER_HUB_HOSTNAME
                        valueFrom:
                          secretKeyRef:
                            name: dance-developer-hub-secret
                            key: hostname
                      - name: PIPELINES_PAC_GH_SECRET
                        valueFrom:
                          secretKeyRef:
                            name: dance-pipelines-secret
                            key: webhook-github-secret
                      - name: PIPELINES_PAC_URL
                        valueFrom:
                          secretKeyRef:
                            name: dance-pipelines-secret
                            key: webhook-url
                      image: "k8s.gcr.io/hyperkube:v1.12.1"
                      name: setup
                      script: |
                        #!/usr/bin/env bash
                        set -o errexit
                        set -o nounset
                        set -o pipefail
                
                        # Output information in YAML so that it can easily be
                        # post-processed if necessary.
                        cat << _EOF_
                        gitops:
                          api-token: \$ARGOCD_TOKEN
                          hostname: \$ARGOCD_HOSTNAME
                        developer-hub:
                          hostname: \$DEVELOPER_HUB_HOSTNAME
                        pipelines:
                          pipelines-as-code:
                            github:
                              # The docs URL explains how to setup the GitHub Application.
                              # Set dummy values for the homepage URL and webhook URL, and
                              # replace them with the final values after the chart is installed.
                              docs-url: https://pipelinesascode.com/docs/install/github_apps/
                              homepage-url: https://\$DEVELOPER_HUB_HOSTNAME
                              callback-url: https://\$DEVELOPER_HUB_HOSTNAME/api/auth/github/handler/frame
                              webhook-url: \$PIPELINES_PAC_URL
                              secret: \$PIPELINES_PAC_GH_SECRET
                        _EOF_
                      workingDir: /tmp
                
              EOF
              echo -n "."
              echo "OK"
        
              echo
              echo "Configuration successful"
        
                
        - name: configure-pipelines
          image: quay.io/redhat-appstudio/appstudio-utils:dbbdd82734232e6289e8fbae5b4c858481a7c057
          command:
            - /bin/bash
            - -c
            - |
              set -o errexit
              set -o nounset
              set -o pipefail
        
              CRD="tektonconfigs"
              echo -n "* Waiting for '$CRD' CRD: "
              while [ $(kubectl api-resources | grep -c "^$CRD ") = "0" ] ; do
                echo -n "."
                sleep 3
              done
              echo "OK"
        
              #
              # All actions MUST be idempotent
              #
              CHART="dance"
              PIPELINES_NAMESPACE="openshift-pipelines"
        
              echo -n "* Waiting for pipelines operator deployment: "
              until kubectl get namespace "$PIPELINES_NAMESPACE" >/dev/null 2>&1; do
                echo -n "."
                sleep 3
              done
              until kubectl get route -n "$PIPELINES_NAMESPACE" pipelines-as-code-controller >/dev/null 2>&1; do
                echo -n "."
                sleep 3
              done
              echo "OK"
        
              echo -n "* Update the TektonConfig resource: "
              until kubectl get tektonconfig config >/dev/null 2>&1; do
                echo -n "."
                sleep 3
              done
              kubectl patch tektonconfig config --type 'merge' --patch '        
                {
                  "spec": {
                    "pipeline": {
                      "enable-bundles-resolver": true,
                      "enable-cluster-resolver": true,
                      "enable-custom-tasks": true,
                      "enable-git-resolver": true,
                      "enable-hub-resolver": true,
                      "enable-tekton-oci-bundles": true
                    },
                    "chain": {
                      "artifacts.oci.storage": "oci",
                      "artifacts.pipelinerun.format": "in-toto",
                      "artifacts.pipelinerun.storage": "oci",
                      "artifacts.taskrun.format": "in-toto",
                      "artifacts.taskrun.storage": "oci",
                      "transparency.enabled": "true",
                      "transparency.url": "http://rekor-server.rekor.svc"
                    }
                  }
                }
                ' >/dev/null
              echo "OK"
        
              echo -n "* Configuring Chains secret: "
              SECRET="signing-secrets"
              if [ "$(kubectl get secret -n "$PIPELINES_NAMESPACE" "$SECRET" -o jsonpath='{.data}' --ignore-not-found --allow-missing-template-keys)" == "" ]; then
                # Delete secret/signing-secrets if already exists since by default cosign creates immutable secrets
                echo -n "."
                kubectl delete secrets  -n "$PIPELINES_NAMESPACE" "$SECRET" --ignore-not-found=true
        
                # To make this run conveniently without user input let's create a random password
                echo -n "."
                RANDOM_PASS=$( openssl rand -base64 30 )
        
                # Generate the key pair secret directly in the cluster.
                # The secret should be created as immutable.
                echo -n "."
                env COSIGN_PASSWORD=$RANDOM_PASS cosign generate-key-pair "k8s://$PIPELINES_NAMESPACE/$SECRET" >/dev/null
              fi
              # If the secret is not marked as immutable, make it so.
              if [ "$(kubectl get secret -n "$PIPELINES_NAMESPACE" "$SECRET" -o jsonpath='{.immutable}')" != "true" ]; then
                echo -n "."
                kubectl patch secret -n "$PIPELINES_NAMESPACE" "$SECRET" --dry-run=client -o yaml \
                  --patch='{"immutable": true}' \
                | kubectl apply -f - >/dev/null
              fi
              echo "OK"
        
              
              echo -n "* Configuring Pipelines-as-Code: "
              if [ "$(kubectl get secret "$CHART-pipelines-secret" -o name --ignore-not-found | wc -l)" = "0" ]; then
                echo -n "."
                WEBHOOK_SECRET="${WEBHOOK_SECRET}"
                kubectl create secret generic "$CHART-pipelines-secret" \
                  --from-literal="webhook-github-secret=$WEBHOOK_SECRET" \
                  --from-literal="webhook-url=$(kubectl get routes -n "$PIPELINES_NAMESPACE" pipelines-as-code-controller -o jsonpath="https://{.spec.host}")" >/dev/null
              else
                WEBHOOK_SECRET="$(kubectl get secret "$CHART-pipelines-secret" ) -o jsonpath="{.data.webhook-github-secret}" | base64 -d"
              fi
              if [ "$(kubectl get secret -n "$PIPELINES_NAMESPACE" "pipelines-as-code-secret" -o name --ignore-not-found | wc -l)" = "0" ]; then
                echo -n "."
                kubectl -n "$PIPELINES_NAMESPACE" create secret generic pipelines-as-code-secret \
                  --from-literal github-application-id="123456" \
                  --from-literal github-private-key="$(echo "SW5zZXJ0IHRoZSBwcml2YXRlIGtleSBkYXRhLCBpbmNsdWRpbmcgdGhlICctLS0tIC4uLiAtLS0tJwpoZWFkZXIgYW5kIGZvb3Rlci4K" | base64 -d)" \
                  --from-literal webhook.secret="$WEBHOOK_SECRET" \
                  --dry-run=client -o yaml | kubectl apply -f - >/dev/null
              fi
              echo "OK"
              
        
              echo
              echo "Configuration successful"
        
      restartPolicy: Never
      serviceAccountName: helm-manager
